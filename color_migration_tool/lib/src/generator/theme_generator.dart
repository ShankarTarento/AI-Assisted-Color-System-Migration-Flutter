import 'dart:io';
import '../models/mapping_config.dart';
import '../models/color_definition.dart';
import '../analyzer/usage_analyzer.dart';

/// Generates Flutter ThemeData code from mapping configuration
class ThemeGenerator {
  /// Generate complete theme package
  Future<void> generateTheme(
    MappingConfig config,
    ProjectColorAnalysis analysis,
    String outputDir,
  ) async {
    print('üé® Generating theme code...');
    
    // Create output directory
    final dir = Directory(outputDir);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    
    // Generate ColorScheme theme file
    final themeFile = await _generateThemeFile(config, analysis, outputDir);
    print('  ‚úì Generated: ${themeFile.path}');
    
    // Generate ThemeExtensions
    final extensionFiles = await _generateExtensions(config, analysis, outputDir);
    for (final file in extensionFiles) {
      print('  ‚úì Generated: ${file.path}');
    }
    
    print('\n‚úÖ Theme generation complete!');
    print('üìÅ Output directory: $outputDir');
  }
  
  /// Generate main theme file with ColorScheme
  Future<File> _generateThemeFile(
    MappingConfig config,
    ProjectColorAnalysis analysis,
    String outputDir,
  ) async {
    final buffer = StringBuffer();
    
    // Header
    buffer.writeln('// Generated Theme File');
    buffer.writeln('// DO NOT EDIT - Generated by color_migration_tool');
    buffer.writeln('// Generated: ${DateTime.now()}');
    buffer.writeln();
    buffer.writeln("import 'package:flutter/material.dart';");
    
    // Import extensions
    if (config.extensions.isNotEmpty) {
      for (final extName in config.extensions.keys) {
        final fileName = _toSnakeCase(extName);
        buffer.writeln("import 'extensions/${fileName}.dart';");
      }
    }
    
    buffer.writeln();
    buffer.writeln('/// Application theme configuration');
    buffer.writeln('class AppTheme {');
    buffer.writeln('  AppTheme._(); // Private constructor');
    buffer.writeln();
    
    // Light theme
    buffer.writeln('  /// Light theme');
    buffer.writeln('  static ThemeData light() {');
    buffer.writeln('    return ThemeData(');
    buffer.writeln('      useMaterial3: true,');
    buffer.writeln('      colorScheme: _lightColorScheme,');
    
    if (config.extensions.isNotEmpty) {
      buffer.writeln('      extensions: [');
      for (final extName in config.extensions.keys) {
        buffer.writeln('        $extName.light(),');
      }
      buffer.writeln('      ],');
    }
    
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
    
    // Dark theme
    buffer.writeln('  /// Dark theme');
    buffer.writeln('  static ThemeData dark() {');
    buffer.writeln('    return ThemeData(');
    buffer.writeln('      useMaterial3: true,');
    buffer.writeln('      colorScheme: _darkColorScheme,');
    
    if (config.extensions.isNotEmpty) {
      buffer.writeln('      extensions: [');
      for (final extName in config.extensions.keys) {
        buffer.writeln('        $extName.dark(),');
      }
      buffer.writeln('      ],');
    }
    
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
    
    // ColorScheme definitions
    buffer.writeln('  /// Light color scheme');
    buffer.writeln('  static const ColorScheme _lightColorScheme = ColorScheme(');
    buffer.writeln('    brightness: Brightness.light,');
    
    // Map strict mappings to ColorScheme
    final schemeColors = _buildColorScheme(config, analysis);
    for (final entry in schemeColors.entries) {
      buffer.writeln('    ${entry.key}: ${entry.value},');
    }
    
    buffer.writeln('  );');
    buffer.writeln();
    
    buffer.writeln('  /// Dark color scheme');
    buffer.writeln('  static const ColorScheme _darkColorScheme = ColorScheme(');
    buffer.writeln('    brightness: Brightness.dark,');
    
    // For now, use same colors (in future, support dark variants)
    for (final entry in schemeColors.entries) {
      buffer.writeln('    ${entry.key}: ${entry.value},');
    }
    
    buffer.writeln('  );');
    buffer.writeln('}');
    
    // Write to file
    final file = File('$outputDir/app_theme.dart');
    await file.writeAsString(buffer.toString());
    
    return file;
  }
  
  /// Build ColorScheme property values from mappings
  Map<String, String> _buildColorScheme(
    MappingConfig config,
    ProjectColorAnalysis analysis,
  ) {
    final schemeColors = <String, String>{};
    
    // Default values (Material 3 defaults)
    schemeColors['primary'] = 'Color(0xFF0066CC)';
    schemeColors['onPrimary'] = 'Color(0xFFFFFFFF)';
    schemeColors['secondary'] = 'Color(0xFF03DAC6)';
    schemeColors['onSecondary'] = 'Color(0xFF000000)';
    schemeColors['error'] = 'Color(0xFFB00020)';
    schemeColors['onError'] = 'Color(0xFFFFFFFF)';
    schemeColors['background'] = 'Color(0xFFFFFFFF)';
    schemeColors['onBackground'] = 'Color(0xFF000000)';
    schemeColors['surface'] = 'Color(0xFFFFFFFF)';
    schemeColors['onSurface'] = 'Color(0xFF000000)';
    
    // Override with mapped values
    for (final entry in config.strictMappings.entries) {
      final colorName = entry.key;
      final mapping = entry.value;
      
      // Get color definition
      final colorDef = analysis.colorDefinitions
          .where((def) => def.qualifiedName == colorName)
          .firstOrNull;
      
      if (colorDef != null) {
        // Extract property name (e.g., "colorScheme.primary" -> "primary")
        final parts = mapping.target.split('.');
        if (parts.length == 2 && parts[0] == 'colorScheme') {
          final propertyName = parts[1];
          schemeColors[propertyName] = 'Color(${colorDef.argbHex})';
        }
      }
    }
    
    return schemeColors;
  }
  
  /// Generate ThemeExtension files
  Future<List<File>> _generateExtensions(
    MappingConfig config,
    ProjectColorAnalysis analysis,
    String outputDir,
  ) async {
    final files = <File>[];
    final extensionsDir = Directory('$outputDir/extensions');
    
    if (!await extensionsDir.exists()) {
      await extensionsDir.create(recursive: true);
    }
    
    for (final entry in config.extensions.entries) {
      final extName = entry.key;
      final extGroup = entry.value;
      
      final file = await _generateExtensionFile(
        extName,
        extGroup,
        analysis,
        extensionsDir.path,
      );
      
      files.add(file);
    }
    
    return files;
  }
  
  /// Generate a single ThemeExtension file
  Future<File> _generateExtensionFile(
    String extensionName,
    ExtensionGroup group,
    ProjectColorAnalysis analysis,
    String outputDir,
  ) async {
    final buffer = StringBuffer();
    final fileName = _toSnakeCase(extensionName);
    
    // Header
    buffer.writeln('// Generated ThemeExtension: $extensionName');
    buffer.writeln('// DO NOT EDIT - Generated by color_migration_tool');
    buffer.writeln();
    buffer.writeln("import 'package:flutter/material.dart';");
    buffer.writeln();
    
    // Class definition
    buffer.writeln('@immutable');
    buffer.writeln('class $extensionName extends ThemeExtension<$extensionName> {');
    
    // Constructor
    buffer.writeln('  const $extensionName({');
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      buffer.writeln('    required this.$propName,');
    }
    buffer.writeln('  });');
    buffer.writeln();
    
    // Properties
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      buffer.writeln('  final Color $propName;');
    }
    buffer.writeln();
    
    // Light variant factory
    buffer.writeln('  static $extensionName light() {');
    buffer.writeln('    return const $extensionName(');
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      final colorValue = colorEntry.value.value;
      buffer.writeln('      $propName: Color($colorValue),');
    }
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
    
    // Dark variant factory (same as light for now)
    buffer.writeln('  static $extensionName dark() {');
    buffer.writeln('    return light(); // TODO: Define dark variants');
    buffer.writeln('  }');
    buffer.writeln();
    
    // copyWith method
    buffer.writeln('  @override');
    buffer.writeln('  ThemeExtension<$extensionName> copyWith({');
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      buffer.writeln('    Color? $propName,');
    }
    buffer.writeln('  }) {');
    buffer.writeln('    return $extensionName(');
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      buffer.writeln('      $propName: $propName ?? this.$propName,');
    }
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln();
    
    // lerp method
    buffer.writeln('  @override');
    buffer.writeln('  ThemeExtension<$extensionName> lerp(');
    buffer.writeln('    ThemeExtension<$extensionName>? other,');
    buffer.writeln('    double t,');
    buffer.writeln('  ) {');
    buffer.writeln('    if (other is! $extensionName) return this;');
    buffer.writeln('    return $extensionName(');
    for (final colorEntry in group.colors.entries) {
      final propName = colorEntry.value.target;
      buffer.writeln('      $propName: Color.lerp($propName, other.$propName, t)!,');
    }
    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    
    // Write to file
    final file = File('$outputDir/$fileName.dart');
    await file.writeAsString(buffer.toString());
    
    return file;
  }
  
  /// Convert PascalCase to snake_case
  String _toSnakeCase(String input) {
    return input
        .replaceAllMapped(
          RegExp(r'[A-Z]'),
          (match) => '_${match.group(0)!.toLowerCase()}',
        )
        .replaceFirst('_', '');
  }
}

/// Extension to add firstOrNull
extension IterableExtension<T> on Iterable<T> {
  T? get firstOrNull {
    final iterator = this.iterator;
    if (iterator.moveNext()) {
      return iterator.current;
    }
    return null;
  }
}
